/*
 * lexer.h -- some useful comment
 *
 * Copyright (c) 2022-2023, NLnet Labs. All rights reserved.
 *
 * SPDX-License-Identifier: BSD-3-Clause
 *
 */
#ifndef LEXER_H
#define LEXER_H

typedef struct token token_t;
struct token {
  int32_t code;
  const char *data;
};

// sorted so that errors, end of file and line feed are less than contiguous
#define END_OF_FILE (0)     // 0x00
#define LINE_FEED (1<<0)    // 0x01
#define CONTIGUOUS (1<<1)   // 0x02
#define QUOTED (1<<2)       // 0x02
#define LEFT_PAREN (1<<4)   // 0x10
#define RIGHT_PAREN (2<<4)  // 0x20
#define BLANK (3<<4)        // 0x30
#define COMMENT (4<<4)      // 0x40

#define STRING (CONTIGUOUS | QUOTED)

static const uint8_t classify[256] = {
  // 0x00 = "\0"
  0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x00 - 0x07
  // 0x09 = "\t", 0x0a = "\n", 0x0d = "\r"
  0x30, 0x20, 0x01, 0x02, 0x02, 0x30, 0x02, 0x02,  // 0x08 - 0x0f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x10 - 0x17
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x18 - 0x1f
  // 0x20 = " ", 0x22 = "\""
  0x30, 0x02, 0x04, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x20 - 0x27
  // 0x28 = "(", 0x29 = ")"
  0x10, 0x20, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x28 - 0x2f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x30 - 0x37
  // 0x3b = ";"
  0x02, 0x02, 0x40, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x38 - 0x3f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x40 - 0x47
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x48 - 0x4f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x50 - 0x57
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x58 - 0x5f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x60 - 0x67
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x68 - 0x6f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x70 - 0x77
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x78 - 0x7f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x80 - 0x87
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x88 - 0x8f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x90 - 0x97
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0x98 - 0x9f
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xa0 - 0xa7
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xa8 - 0xaf
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xb0 - 0xb7
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xb8 - 0xbf
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xc0 - 0xc7
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xc8 - 0xcf
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xd0 - 0xd7
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xd8 - 0xdf
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xe0 - 0xe7
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xe8 - 0xef
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xf0 - 0xf7
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  // 0xf8 - 0xff
};

static const char line_feed[ZONE_BLOCK_SIZE] = { '\n', '\0' };

// we'd have contiguous + quoted simd tables that each have an entry for
// blank + special. we need two tables mainly for the contiguous table
// as the blank and special characters clash. we could alter the input
// (see #30), but that really takes just as much operations, so probably
// best to keep it simple...

typedef struct delimiter_table delimiter_table_t;

zone_alignas(64)
struct delimiter_table {
  simd_table_t special;
  simd_table_t blank;
};

static const delimiter_table_t delimiters[5] = {
  // padding
  { { 0 }, { 0 } },
  // padding
  { { 0 }, { 0 } },
  // contiguous
  { SIMD_TABLE( // special
      0x00, // 0x00 : "\0" : 0x00 -- end-of-file
      0x00, // 0x01
      0x22, // 0x02 : "\"" : 0x22 -- start/end quoted
      0x00, // 0x03
      0x00, // 0x02
      0x00, // 0x05
      0x00, // 0x06
      0x00, // 0x07
      0x28, // 0x08 :  "(" : 0x28 -- start grouped
      0x29, // 0x09 :  ")" : 0x29 -- end grouped
      0x0a, // 0x0a : "\n" : 0x0a -- end-of-line
      0x3b, // 0x0b :  ";" : 0x3b -- start comment
      0x00, // 0x0c
      0x00, // 0x0d
      0x00, // 0x0e
      0x00  // 0x0f
    ),
    SIMD_TABLE( // blank
      0x20, // 0x00 :  " " : 0x20 -- space
      0x00, // 0x01
      0x00, // 0x02
      0x00, // 0x03
      0x00, // 0x02
      0x00, // 0x05
      0x00, // 0x06
      0x00, // 0x07
      0x00, // 0x08
      0x09, // 0x09 : "\t" : 0x09 -- tab
      0x00, // 0x0a
      0x00, // 0x0b
      0x00, // 0x0c
      0x0d, // 0x0d : "\r" : 0x0d -- carriage return
      0x00, // 0x0e
      0x00  // 0x0f
    )
  },
  // padding
  { { 0 }, { 0 } },
  // quoted
  { SIMD_TABLE( // special
      0x00, // 0x00 : "\0" : 0x00 -- end-of-file
      0x00, // 0x01
      0x22, // 0x02 : "\"" : 0x22 -- start/end quoted
      0x00, // 0x03
      0x00, // 0x02
      0x00, // 0x05
      0x00, // 0x06
      0x00, // 0x07
      0x00, // 0x08
      0x00, // 0x09
      0x00, // 0x0a
      0x00, // 0x0b
      0x00, // 0x0c
      0x00, // 0x0d
      0x00, // 0x0e
      0x00  // 0x0f
    ),
    SIMD_TABLE( // blank
      0x00, // 0x00
      0x00, // 0x01
      0x00, // 0x02
      0x00, // 0x03
      0x00, // 0x02
      0x00, // 0x05
      0x00, // 0x06
      0x00, // 0x07
      0x00, // 0x08
      0x00, // 0x09
      0x00, // 0x0a
      0x00, // 0x0b
      0x00, // 0x0c
      0x00, // 0x0d
      0x00, // 0x0e
      0x00  // 0x0f
    )
  }
};

static zone_no_inline int32_t step(zone_parser_t *parser, token_t *token);

static zone_inline int32_t lex(zone_parser_t *parser, token_t *token)
{
  for (;;) {
    token->data = parser->file->indexer.head[0].data;

    switch (*token->data) {
      case '\0':
        return step(parser, token);
      case '\n':
        // data equals line_feed on embedded newlines
        if (zone_unlikely(token->data == line_feed))
          parser->file->line += parser->file->indexer.head[0].lines;
        parser->file->line++;
        parser->file->indexer.head++;
        if (parser->file->grouped)
          break;
        parser->file->start_of_line = classify[ (uint8_t)*(token->data+1) ] != BLANK;
        return token->code = LINE_FEED;
      case '\"':
        token->data++;
        parser->file->indexer.head++;
        return token->code = QUOTED;
      case '(':
        if (parser->file->grouped)
          SYNTAX_ERROR(parser, "Nested opening brace");
        parser->file->indexer.head++;
        parser->file->grouped = true;
        break;
      case ')':
        if (!parser->file->grouped)
          SYNTAX_ERROR(parser, "Missing opening brace");
        parser->file->indexer.head++;
        parser->file->grouped = false;
        break;
      default:
        parser->file->indexer.head++;
        return token->code = CONTIGUOUS;
    }
  }
}

#endif // LEXER_H
